# playbooks/04_generate-auth-secret.yml
---
- name: 🔐 4 - Generar y cifrar Secret para autenticación del Longhorn Dashboard
  hosts: localhost
  gather_facts: false

  vars_files:
    - ../vars/main.yml  # Variables: longhorn_auth_user y longhorn_auth_pass

  vars:
    kubeconfig_path: "/home/victory/.kube/config"
    kubeseal_path: "/usr/local/bin/kubeseal"
    kubectl_path: "/usr/local/bin/kubectl"
    python_bin: "/usr/bin/python3"
    files_dir: "{{ playbook_dir }}/files"
    rendered_secret_path: "{{ files_dir }}/longhorn-dashboard-secret.yaml"
    sealed_secret_path: "{{ files_dir }}/longhorn-dashboard-sealed.yaml"
    longhorn_namespace: "longhorn-system"
    secret_name: "longhorn-dashboard-auth"

  tasks:

    - name: ✅ Verificar que kubeseal está instalado
      stat:
        path: "{{ kubeseal_path }}"
      register: kubeseal_check

    - name: ❌ Error si kubeseal no está instalado
      fail:
        msg: "kubeseal no encontrado en {{ kubeseal_path }}"
      when: not kubeseal_check.stat.exists

    - name: ✅ Verificar que kubectl está instalado
      stat:
        path: "{{ kubectl_path }}"
      register: kubectl_check

    - name: ❌ Error si kubectl no está instalado
      fail:
        msg: "kubectl no encontrado en {{ kubectl_path }}"
      when: not kubectl_check.stat.exists

    - name: 📁 Crear directorio local para secrets (si no existe)
      file:
        path: "{{ files_dir }}"
        state: directory
        mode: "0755"

    - name: 🔐 Generar hash htpasswd (basicAuth con MD5)
      command: >
        {{ python_bin }} -c "import crypt, base64; raw='{{ longhorn_auth_user }}:' + crypt.crypt('{{ longhorn_auth_pass }}', crypt.mksalt(crypt.METHOD_MD5)); print(base64.b64encode(raw.encode()).decode())"
      register: longhorn_htpasswd_b64
      changed_when: true
      failed_when: longhorn_htpasswd_b64.rc != 0 or longhorn_htpasswd_b64.stdout == ""

    - name: 📄 Renderizar plantilla del Secret plano (YAML)
      template:
        src: ../templates/secrets/basic-auth-secret.yaml.j2
        dest: "{{ rendered_secret_path }}"
      vars:
        basic_auth: "{{ longhorn_htpasswd_b64.stdout }}"
        secret_name: "{{ secret_name }}"
        namespace: "{{ longhorn_namespace }}"

    - name: 🔐 Cifrar el Secret con kubeseal (SealedSecret)
      shell: >
        {{ kubeseal_path }}
        --controller-name sealed-secrets-controller
        --controller-namespace {{ longhorn_namespace }}
        --format yaml
        < "{{ rendered_secret_path }}" > "{{ sealed_secret_path }}"
      args:
        executable: /bin/bash
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      changed_when: true
      register: seal_output
      failed_when: seal_output.rc != 0

    - name: 📥 Aplicar el SealedSecret al clúster (opcional)
      shell: >
        {{ kubectl_path }} apply -f "{{ sealed_secret_path }}"
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: apply_output
      changed_when: "'created' in apply_output.stdout or 'configured' in apply_output.stdout"
      failed_when: apply_output.rc != 0

    - name: 📦 Mostrar hash base64 generado (debug opcional)
      debug:
        msg: "{{ longhorn_htpasswd_b64.stdout }}"
      when: debug | default(false)
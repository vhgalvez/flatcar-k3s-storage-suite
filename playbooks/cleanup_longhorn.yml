# playbooks/cleanup_longhorn.yml
---
- name: ğŸ›‘ 1 - PreparaciÃ³n para la limpieza de Longhorn
  hosts: controller
  become: true
  gather_facts: false

  vars:
    kubeconfig_path: "/home/victory/.kube/config"
    kubectl_bin: "/usr/local/bin/kubectl"
    helm_bin: "/usr/local/bin/helm"
    namespace: "longhorn-system"
    release_name: "longhorn"

  tasks:
    - name: ğŸ§ª Instalar jq si no estÃ¡ presente
      package:
        name: jq
        state: present

    - name: ğŸ” Verificar si el namespace de Longhorn existe
      shell: "{{ kubectl_bin }} get namespace {{ namespace }} --kubeconfig {{ kubeconfig_path }} --ignore-not-found"
      register: longhorn_ns_check
      failed_when: false
      changed_when: false

    - name: ğŸ’£ 2 - Eliminar Helm release de Longhorn (si existe)
      when: longhorn_ns_check.rc == 0
      shell: |
        export KUBECONFIG={{ kubeconfig_path }}
        {{ helm_bin }} uninstall {{ release_name }} -n {{ namespace }} || true
      changed_when: true
      ignore_errors: true

    - name: ğŸ§¼ 3 - Borrar todos los recursos del namespace Longhorn
      when: longhorn_ns_check.rc == 0
      shell: |
        export KUBECONFIG={{ kubeconfig_path }}
        {{ kubectl_bin }} delete all --all -n {{ namespace }} --ignore-not-found --grace-period=0 --force
        {{ kubectl_bin }} delete pvc --all -n {{ namespace }} --ignore-not-found --grace-period=0 --force
        {{ kubectl_bin }} delete svc --all -n {{ namespace }} --ignore-not-found --grace-period=0 --force
      changed_when: true
      ignore_errors: true

- name: ğŸ’£ 4 - Eliminar CRDs Longhorn forzadamente
  hosts: controller
  become: true
  gather_facts: false

  vars:
    kubeconfig_path: "/home/victory/.kube/config"
    kubectl_bin: "/usr/local/bin/kubectl"

  tasks:
    - name: ğŸ§¹ Iniciando eliminaciÃ³n de CRDs de Longhorn...
      shell: |
        export PATH=$PATH:/usr/local/bin
        export KUBECONFIG={{ kubeconfig_path }}
        echo "ğŸ§¹ Iniciando eliminaciÃ³n de CRDs de Longhorn..."
        max_retries=3
        for crd in $(kubectl get crd -o name --kubeconfig {{ kubeconfig_path }} | grep 'longhorn.io'); do
          name=$(basename "$crd")
          echo "ğŸ”§ Procesando CRD: $name"
          for i in $(seq 1 $max_retries); do
            # Quitar finalizers
            {{ kubectl_bin }} patch crd "$name" -p '{"metadata":{"finalizers":[]}}' --type=merge --kubeconfig {{ kubeconfig_path }} && break || sleep 5
          done
          # Eliminar CRD
          {{ kubectl_bin }} delete crd "$name" --grace-period=0 --force --kubeconfig {{ kubeconfig_path }} || true
          echo "âœ… $name procesado."
        done
        # VerificaciÃ³n final
        remaining_crds=$({{ kubectl_bin }} get crd --kubeconfig {{ kubeconfig_path }} | grep 'longhorn.io' || echo "âœ… No hay CRDs restantes")
        if [[ "$remaining_crds" != "âœ… No hay CRDs restantes" ]]; then
          echo "âŒ CRDs restantes: $remaining_crds"
          exit 1
        fi
      register: crd_cleanup
      failed_when: "'âŒ CRDs restantes' in crd_cleanup.stdout"
      changed_when: true

    - name: ğŸ” Verificar si los CRDs de Longhorn fueron eliminados
      shell: |
        export KUBECONFIG={{ kubeconfig_path }}
        crd_check=$(kubectl get crd --kubeconfig {{ kubeconfig_path }} | grep 'longhorn.io')
        if [ -n "$crd_check" ]; then
          echo "âš ï¸ Los CRDs de Longhorn aÃºn existen: $crd_check"
          exit 1
        else
          echo "âœ… Los CRDs de Longhorn fueron eliminados correctamente."
        fi
      register: crd_verification
      failed_when: crd_verification.rc != 0
      changed_when: false

- name: ğŸ—‘ï¸ 5 - Eliminar el namespace Longhorn
  hosts: controller
  become: true
  gather_facts: false

  vars:
    kubeconfig_path: "/home/victory/.kube/config"
    kubectl_bin: "/usr/local/bin/kubectl"
    namespace: "longhorn-system"

  tasks:
    - name: ğŸ§¨ Verificar y eliminar finalizers del namespace si existen
      shell: |
        export KUBECONFIG={{ kubeconfig_path }}
        if {{ kubectl_bin }} get namespace {{ namespace }} --kubeconfig {{ kubeconfig_path }} -o json | jq -e '.spec.finalizers | length > 0' > /dev/null; then
          echo "âš ï¸ Se encontraron finalizers en el namespace '{{ namespace }}'. Intentando eliminarlos..."
          kubectl patch namespace {{ namespace }} --kubeconfig {{ kubeconfig_path }} -p '{"metadata":{"finalizers":[]}}' --type=merge
          sleep 5
          if {{ kubectl_bin }} get namespace {{ namespace }} --kubeconfig {{ kubeconfig_path }} -o json | jq -e '.spec.finalizers | length > 0' > /dev/null; then
            echo "âš ï¸ Los finalizers del namespace aÃºn persisten."
          else
            echo "âœ… Finalizers del namespace eliminados."
          fi
        else
          echo "âœ… El namespace '{{ namespace }}' no tiene finalizers."
        fi
      changed_when: true
      failed_when: false

    - name: âŒ Eliminar el namespace completamente (con espera activa)
      shell: |
        export KUBECONFIG={{ kubeconfig_path }}
        echo "ğŸ’£ Intentando eliminar el namespace '{{ namespace }}'..."
        {{ kubectl_bin }} delete namespace {{ namespace }} --kubeconfig {{ kubeconfig_path }} --grace-period=0 --force --ignore-not-found
        for i in $(seq 1 30); do
          sleep 2
          if ! {{ kubectl_bin }} get namespace {{ namespace }} --kubeconfig {{ kubeconfig_path }} &>/dev/null; then
            echo "âœ… Namespace '{{ namespace }}' eliminado."
            exit 0
          fi
        done
        echo "âš ï¸ El namespace '{{ namespace }}' sigue existiendo despuÃ©s de 60 segundos. Puede haber un problema."
        exit 1
      register: ns_delete_result
      failed_when: ns_delete_result.rc != 0
      changed_when: true

    - name: ğŸš¨ Forzar eliminaciÃ³n final si aÃºn existe (mÃ©todo alternativo)
      shell: |
        export KUBECONFIG={{ kubeconfig_path }}
        if {{ kubectl_bin }} get namespace {{ namespace }} --kubeconfig {{ kubeconfig_path }} &>/dev/null; then
          echo "ğŸš¨ Intentando forzar la eliminaciÃ³n del namespace '{{ namespace }}' por mÃ©todo alternativo..."
          kubectl get namespace {{ namespace }} --kubeconfig {{ kubeconfig_path }} -o json | jq 'del(.spec.finalizers)' > /tmp/ns-force.json
          kubectl replace --raw "/api/v1/namespaces/{{ namespace }}/finalize" -f /tmp/ns-force.json --force --grace-period=0 --kubeconfig {{ kubeconfig_path }} || true
          rm -f /tmp/ns-force.json
          sleep 5
          {{ kubectl_bin }} delete namespace {{ namespace }} --force --grace-period=0 --ignore-not-found --kubeconfig {{ kubeconfig_path }} || true
          echo "âœ… Intento de eliminaciÃ³n forzada completado."
        else
          echo "âœ… El namespace ya no existe."
        fi
      changed_when: true
      failed_when: false

    - name: ğŸ§¾ Mostrar resumen de limpieza del namespace
      debug:
        var: ns_delete_result

    - name: ğŸ§¾ Mostrar resumen de limpieza del namespace
      debug:
        var: ns_delete_result

- name: ğŸ’½ 6 - Limpiar completamente /dev/vdb en storage y workers
  hosts: storage,workers
  become: true
  gather_facts: false

  tasks:
    - name: ğŸ” Mostrar si hay montajes activos en /dev/vdb
      raw: mount | grep vdb || true
      changed_when: false

    - name: ğŸ’£ Desmontar volÃºmenes
      raw: |
        umount -f /mnt/longhorn-disk 2>/dev/null || true
        umount -f /srv/nfs/postgresql 2>/dev/null || true
        umount -f /srv/nfs/shared 2>/dev/null || true
        sleep 2
      ignore_errors: true

    - name: â³ Esperar a que /dev/vdb ya no estÃ© montado
      raw: |
        for i in $(seq 1 5); do
          mount | grep -q vdb || exit 0
          sleep 1
        done
        exit 1
      register: umount_check
      failed_when: umount_check.rc != 0
      changed_when: false

    - name: âŒ Detener servicios que puedan bloquear el disco (solo en storage)
      raw: |
        systemctl stop nfs-server || true
        systemctl stop iscsid || true
      when: "'storage' in group_names"

    - name: ğŸ§¹ Eliminar volÃºmenes LVM (si existen)
      raw: |
        lvremove -f /dev/vg_storage/postgres_lv 2>/dev/null || true
        lvremove -f /dev/vg_storage/shared_lv 2>/dev/null || true
        lvremove -f /dev/vg_storage/longhorn_lv 2>/dev/null || true
        sleep 1

    - name: ğŸ§± Eliminar grupo de volÃºmenes
      raw: vgremove -f vg_storage 2>/dev/null || true

    - name: ğŸ’½ Eliminar volumen fÃ­sico
      raw: pvremove -f /dev/vdb1 2>/dev/null || true

    - name: â Eliminar particiÃ³n y limpiar firmas
      raw: |
        parted -s /dev/vdb rm 1 2>/dev/null || true
        wipefs -a /dev/vdb 2>/dev/null || true

    - name: ğŸ§¼ Esperar a que el sistema asiente los cambios
      raw: udevadm settle
